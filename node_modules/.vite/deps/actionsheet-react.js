import {
  require_jsx_runtime
} from "./chunk-UHPGSKKB.js";
import {
  require_react
} from "./chunk-HKN3T6U5.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/actionsheet-react/build/index.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var ActionSheet = (0, import_react.memo)((0, import_react.forwardRef)(({ onClose, children, sheetStyle, bgStyle, mouseEnable = true, touchEnable = true, threshold = 50, opacity = 1, zIndex = 998, closeOnBgTap = true, bgTransition = "opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)", className = "action-sheet", sheetTransition = "transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)", reverse = false, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy }, ref) => {
  const [show, setShow] = (0, import_react.useState)(false);
  const [isDragging, setIsDragging] = (0, import_react.useState)(false);
  const pressedRef = (0, import_react.useRef)(false);
  const sheetRef = (0, import_react.useRef)(null);
  const animationRef = (0, import_react.useRef)(0);
  const masterOffsetRef = (0, import_react.useRef)(0);
  const startYRef = (0, import_react.useRef)(0);
  const backgroundRef = (0, import_react.useRef)(null);
  (0, import_react.useImperativeHandle)(ref, () => ({
    open: () => setShow(true),
    close: () => setShow(false),
    isOpen: () => show
  }), [show]);
  const handleClose = (0, import_react.useCallback)(() => {
    setShow(false);
    onClose?.();
  }, [onClose]);
  const handleBgClick = (0, import_react.useCallback)(() => {
    if (closeOnBgTap && !isDragging) {
      handleClose();
    }
  }, [closeOnBgTap, isDragging, handleClose]);
  const requestSheetDown = (0, import_react.useCallback)(() => {
    const sheet = sheetRef.current;
    if (!sheet)
      return false;
    sheet.style.transition = sheetTransition;
    sheet.style.transform = reverse ? "translate3d(0, -100%, 0)" : "translate3d(0, 100%, 0)";
    return true;
  }, [reverse, sheetTransition]);
  const requestSheetUp = (0, import_react.useCallback)(() => {
    const sheet = sheetRef.current;
    if (!sheet)
      return false;
    sheet.style.transform = "translate3d(0, 0%, 0)";
    return true;
  }, []);
  const updatePosition = (0, import_react.useCallback)(() => {
    const sheet = sheetRef.current;
    if (!sheet || animationRef.current === 0)
      return false;
    sheet.style.transform = `translate3d(0, ${masterOffsetRef.current}px, 0)`;
    return true;
  }, []);
  const move = (0, import_react.useCallback)((offset) => {
    if (!reverse && offset > 0) {
      masterOffsetRef.current = offset;
      animationRef.current = requestAnimationFrame(updatePosition);
      return true;
    } else if (reverse && offset < 0) {
      masterOffsetRef.current = offset;
      animationRef.current = requestAnimationFrame(updatePosition);
      return true;
    }
    return false;
  }, [reverse, updatePosition]);
  const handleStart = (0, import_react.useCallback)((clientY) => {
    const sheet = sheetRef.current;
    if (!sheet)
      return;
    sheet.style.transition = "none";
    startYRef.current = clientY;
    pressedRef.current = true;
    setIsDragging(true);
  }, []);
  const handleMove = (0, import_react.useCallback)((clientY) => {
    if (!pressedRef.current)
      return;
    const offset = clientY - startYRef.current;
    move(offset);
  }, [move]);
  const handleEnd = (0, import_react.useCallback)(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = 0;
    }
    pressedRef.current = false;
    setIsDragging(false);
    if (Math.abs(masterOffsetRef.current) > threshold) {
      handleClose();
    } else {
      requestSheetUp();
    }
    masterOffsetRef.current = 0;
  }, [threshold, handleClose, requestSheetUp]);
  const onTouchStart = (0, import_react.useCallback)((event) => {
    if (!touchEnable)
      return;
    event.preventDefault();
    handleStart(event.touches[0].clientY);
  }, [touchEnable, handleStart]);
  const onTouchMove = (0, import_react.useCallback)((event) => {
    if (!touchEnable || !pressedRef.current)
      return;
    event.preventDefault();
    handleMove(event.touches[0].clientY);
  }, [touchEnable, handleMove]);
  const onTouchEnd = (0, import_react.useCallback)((event) => {
    if (!touchEnable)
      return;
    event.preventDefault();
    handleEnd();
  }, [touchEnable, handleEnd]);
  const onMouseDown = (0, import_react.useCallback)((event) => {
    if (!mouseEnable)
      return;
    event.preventDefault();
    handleStart(event.clientY);
  }, [mouseEnable, handleStart]);
  const onMouseMove = (0, import_react.useCallback)((event) => {
    if (!mouseEnable || !pressedRef.current)
      return;
    event.preventDefault();
    handleMove(event.clientY);
  }, [mouseEnable, handleMove]);
  const onMouseUp = (0, import_react.useCallback)((event) => {
    if (!mouseEnable)
      return;
    event.preventDefault();
    handleEnd();
  }, [mouseEnable, handleEnd]);
  const onKeyDown = (0, import_react.useCallback)((event) => {
    if (event.key === "Escape") {
      handleClose();
    }
  }, [handleClose]);
  (0, import_react.useEffect)(() => {
    if (show) {
      requestSheetUp();
      const sheet = sheetRef.current;
      if (sheet) {
        sheet.focus();
      }
    } else {
      requestSheetDown();
    }
  }, [show, requestSheetUp, requestSheetDown]);
  (0, import_react.useEffect)(() => {
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);
  const backgroundStyles = (0, import_react.useMemo)(() => ({
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    backdropFilter: "blur(4px)",
    WebkitBackdropFilter: "blur(4px)",
    transition: bgTransition,
    opacity: show ? opacity : 0,
    visibility: show ? "visible" : "hidden",
    zIndex: show ? zIndex : -1,
    willChange: "opacity, visibility",
    ...bgStyle
  }), [show, opacity, zIndex, bgTransition, bgStyle]);
  const sheetStyles = (0, import_react.useMemo)(() => ({
    position: "fixed",
    left: 0,
    width: "100%",
    maxWidth: "100vw",
    backgroundColor: "#ffffff",
    borderRadius: reverse ? "0 0 16px 16px" : "16px 16px 0 0",
    touchAction: "none",
    zIndex: zIndex + 1,
    outline: "none",
    willChange: "transform",
    transform: show ? "translate3d(0, 0%, 0)" : reverse ? "translate3d(0, -100%, 0)" : "translate3d(0, 100%, 0)",
    transition: show ? sheetTransition : "none",
    ...reverse ? {
      top: 0,
      borderBottomLeftRadius: 16,
      borderBottomRightRadius: 16,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    } : {
      bottom: 0,
      borderTopLeftRadius: 16,
      borderTopRightRadius: 16,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    },
    ...sheetStyle
  }), [show, reverse, zIndex, sheetTransition, sheetStyle]);
  if (!show && !isDragging) {
    return null;
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { ref: backgroundRef, className, style: backgroundStyles, onClick: handleBgClick, "aria-hidden": "true" }), (0, import_jsx_runtime.jsx)("div", { ref: sheetRef, style: sheetStyles, onMouseDown, onMouseMove, onMouseUp, onTouchStart, onTouchMove, onTouchEnd, onKeyDown, role: "dialog", "aria-modal": "true", "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, tabIndex: -1, children })] });
}));
ActionSheet.displayName = "ActionSheet";
export {
  ActionSheet as default
};
//# sourceMappingURL=actionsheet-react.js.map
